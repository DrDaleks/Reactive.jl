<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Shashi Gowda">
  <meta charset="utf-8">
  <title>Introduction - Reactive.jl</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>
  <script src="js/bootstrap.min.js" type="text/javascript"></script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar" style="z-index: 3">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">Reactive 0.3.2</div></li>
          <li><a href="http://github.com/JuliaLang/Reactive.jl">Code</a></li>
          <li><a href="http://github.com/JuliaLang/Reactive.jl/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container" style="z-index: auto">
    <div class="row">
      <div class="col-sm-7">
      <div id="body-content">
<figure>
<img src="Star-On-Machine.jpg" />
</figure>
<p>Reactive.jl is a Julia package for <a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive Programming</a>. It makes writing event-driven programs simple.</p>
<p>Reactive borrows its vocabulary from <a href="http://elm-lang.org/">Elm</a>.</p>
<h1 id="what-is-reactive-programming">What is reactive programming?</h1>
<p><em>Reactive programming</em> is a way of creating event-driven programs in terms of <strong>streams of data</strong>. The streams in this package are called Signals, the name signifies the fact that they always have a value, and are conceptually continuous like electrical signals. For example, a keyboard gives out a <em>signal of keys pressed</em>, a timer might give out a <em>signal of timestamps</em>, a database can consume a <em>signal of queries</em> and so on. Reactive also provides functions for common operations on signals such as transforming, filtering, merging, sampling, and throttling.</p>
<h1 id="getting-started">Getting Started</h1>
<p>To install the latest release of Reactive, run the following in the Julia REPL.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">Pkg.add(<span class="st">&quot;Reactive&quot;</span>)</code></pre>
<p>To start using it, import it:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">
using Reactive</code></pre>
<h1 id="a-tutorial-introduction">A Tutorial Introduction</h1>
<h2 id="signals">Signals</h2>
<!-- the dot language mapping of signal types:
        input: 'hexagon'
        map: 'invtrapezium'
        foldp: 'rect'
        sampleOn: 'house'
        constant: 'none'
        dropRepeats: 'doubleoctagon';
        merge: 'invtriangle';
        default: 'ellipse';
-->
<p>The basic currency of Reactive programs is the signal. <code>Signal{T}</code> represents a time-varying value of type <code>T</code>.</p>
<p>A signal can be created using the <code>Signal</code> constructor, and must be given an inital value.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>
julia&gt; x = Signal(<span class="fl">0</span>)
Signal{<span class="dt">Int64</span>}(<span class="fl">0</span>, nactions=<span class="fl">0</span>)

julia&gt; value(x)
<span class="fl">0</span></code></pre>
<p>to update the value in a signal, use the <code>push!</code> function on signals.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>
julia&gt; push!(x, <span class="fl">42</span>)

julia&gt; value(x)
<span class="fl">42</span></code></pre>
<p>the <code>push!</code> function updates the signal asynchronously via a central channel of updates. Below we will learn ways to derive dependent signals from one or more signals that already exist.</p>
<h2 id="derived-signals">Derived signals</h2>
<p>The <code>map</code> function can be used to transform signals by applying a function.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; xsquared = map(a -&gt; a*a, x)

julia&gt; value(xsquared)
<span class="fl">1764</span> <span class="co"># 42^2</span></code></pre>
<p>Now for every value of <code>x</code>, <code>xsquared</code> will hold its square.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; push!(x, <span class="fl">3</span>)

julia&gt; value(xsquared)
<span class="fl">9</span></code></pre>
<p>The type of the <code>map</code> signal can be specified using a keyword argument <code>typ=T</code> to <code>map</code>. If omitted, it is determined from the type returned by the function, using the current <code>value</code>s of its inputs. If you want to set an initial value without computing it from the current value of the input signals, you can specify it using the <code>init</code> keyword argument. <code>map</code> can take more than one signals as argument. Here is a demonstration of these three points.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; y = map(+, x, xsquared; typ=<span class="dt">Float64</span>, init=<span class="fl">0</span>)

julia&gt; value(y) <span class="co"># Will give the initial value</span>
<span class="fl">0.0</span>

julia&gt; push!(x, <span class="fl">4</span>)

julia&gt; value(y) <span class="co"># will be 4 + 4^2</span>
<span class="fl">20.0</span></code></pre>
<p>Note that, signal nodes that do not have any reference in Reactive are admissible to <a href="https://en.wikipedia.org/wiki/Garbage_collection">garbage collection</a> and subsequent termination of updates. So if you are creating a signal with <code>map</code> and to do some side effect (like printing) and don't plan to keep a reference to it, it may be stopped in the next GC pass. To prevent this from happening, you can <em>preserve</em> a signal using the <code>preserve</code> function.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; preserve(map(println, x))
Signal{<span class="dt">Void</span>}(nothing, nactions=<span class="fl">0</span>) <span class="co"># the type is Void because that&#39;s the return type of println</span>
<span class="fl">4</span>

julia&gt; push!(x, <span class="fl">25</span>)
<span class="fl">25</span> <span class="co"># printed by the above signal</span></code></pre>
<p><code>foreach(f, x)</code> is a shorthand for <code>preserve(map(f, x))</code>. So the above could also have been written as <code>foreach(println, x)</code>.</p>
<p><code>map</code> is a very useful function on signals. We will see an example of map below.</p>
<p><strong>Example: A simple animation</strong></p>
<p>Let's use <code>map</code> to create an animation of a bouncing ball using <a href="http://composejl.org">Compose.jl</a>.</p>
<p>Our goal is to create a signal of Compose pictures that updates over time. To do this we will first create a function which given a time <code>t</code>, returns a picture of the ball at that time <code>t</code>. We will worry about updating this time <code>t</code> later.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">function</span> drawball(t)
  y = <span class="fl">1</span>-abs(sin(t)) <span class="co"># The y coordinate.</span>
  compose(context(), circle(<span class="fl">0.5</span>, y, <span class="fl">0.04</span>))
<span class="kw">end</span></code></pre>
<p>In this function the <code>y</code> coordinate of the ball at any time <code>t</code> is <code>1-abs(sin(t))</code> - when you plot this function over <code>t</code>, you can see that it looks like the bouncing of a ball.</p>
<p>Next, we need a signal that updates at a reasonable rate every second. That's where the <code>fps</code> function comes in handy. <code>fps(rate)</code> returns a signal which updates <code>rate</code> times every second.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; ticks = fps(<span class="fl">60</span>)</code></pre>
<p>The <code>ticks</code> signal itself updates to the time elapsed between the current update and the previous update, although this is useful, for the sake of this example, we will use <code>map</code> to create a signal of time stamps from this signal.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; timestamps = map(_ -&gt; time(), ticks)</code></pre>
<p>Now that we have a signal of timestamps, we can use this to create a signal of compose graphics which will be our animation.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; anim = map(drawball, timestamps)</code></pre>
<p><strong>Try it.</strong> The <a href="https://github.com/JuliaLang/Interact.jl">Interact</a> package allows you to render <code>Signal</code> objects as they update over time in IJulia notebooks. Try the following code in an IJulia notebook to see the animation we just created.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">using Reactive, Interact, Compose

<span class="kw">function</span> drawball(t)
  y = <span class="fl">1</span>-abs(sin(t)) <span class="co"># The y coordinate.</span>
  compose(context(), circle(<span class="fl">0.5</span>, y, <span class="fl">0.04</span>))
<span class="kw">end</span>

ticks = fps(<span class="fl">60</span>)
timestamps = map(_ -&gt; time(), ticks)
map(drawball, timestamps)</code></pre>
<p>The complete example points to the usual structure of programs written with Reactive. It usually consists of stateless functions (such as <code>drawball</code>) and then wiring input signals to these stateless functions to create the output signal. Below we will see some more involved examples with other operations on signals.</p>
<h2 id="maintaining-state">Maintaining State</h2>
<p><a href="api.html#foldp"><code>foldp</code></a> can be used to accumulate a value over time. You might have learned about <a href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">foldl and foldr</a> functions on collection objects. <code>foldp</code> is a similar function, the name stands for &quot;fold over past values&quot;.</p>
<p>Let's look at how it works: <code>y = foldp(f, init, x)</code></p>
<p>Here, <code>y</code> is a signal whose initial value is <code>init</code>, and when the signal <code>x</code> updates, <code>f</code> is applied to the current value of <code>y</code> and the current value of <code>x</code> and the result is again stored in <code>y</code>.</p>
<p>As an example:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; x = Signal(<span class="fl">0</span>)

julia&gt; y = foldp(+, <span class="fl">0</span>, x)

julia&gt; push!(x, <span class="fl">1</span>)

julia&gt; value(y)
<span class="fl">1</span>

julia&gt; push!(x, <span class="fl">2</span>)

julia&gt; value(y)
<span class="fl">3</span>

julia&gt; push!(x, <span class="fl">3</span>)

julia&gt; value(y)
<span class="fl">3</span></code></pre>
<p>When we wrote <code>y=foldp(+, 0, x)</code> we created a signal <code>y</code> which collects updates to <code>x</code> using the function <code>+</code> and starting from <code>0</code>. In other words, <code>y</code> holds the sum of all updates to <code>x</code>.</p>
<p>We can rewrite the above bouncing ball example by summing time-deltas given by <code>fps</code> instead of calling time() as follows.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">ticks = fps(<span class="fl">60</span>)
t = foldp(+, <span class="fl">0.0</span>, ticks)
map(drawball, t)</code></pre>
<p>If one were to use <code>fpswhen(switch, 60)</code> instead of <code>fps(60)</code> here to start and stop the fps signal with respect to some other boolean signal called <code>switch</code>, after switching off the animation and switching it on, the ball would start off where it was paused with the foldp version of the animation.</p>
<h2 id="filtering">Filtering</h2>
<p>Another important operator on signals is <code>filter</code>. It can be used to filter only those updates which are true according to a given condition.</p>
<p><code>filter(a -&gt; a % 2 == 0, x)</code> will only keep even updates to the integer signal <code>x</code>.</p>
<p>A variation of <code>filter</code> called <code>filterwhen</code> lets you keep updates to a signal only when another boolean signal is true.</p>
<p><code>filterwhen(switch_signal, signal_to_filter)</code></p>
<h2 id="merging">Merging</h2>
<p><code>d = merge(a,b,c)</code> will merge updates to <code>a</code>, <code>b</code> and <code>c</code> to produce a signle signal <code>d</code>.</p>
<h2 id="drop-repeats">Drop repeats</h2>
<p>You can drop repeated updates to a signal with <a href="api.html#droprepeats"><code>droprepeats</code></a></p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">julia&gt; p = Signal(<span class="fl">0</span>)

julia&gt; foreach(println, p)

julia&gt; push!(p, <span class="fl">0</span>)

julia&gt; push!(p, <span class="fl">1</span>)
<span class="fl">1</span>

julia&gt; push!(p, <span class="fl">1</span>)</code></pre>
<p>Notice how the value of p did not get printed when it didn't change from the previous value.</p>
<p><strong>Example: A Voting System</strong></p>
<p>To illustrate the functions described above, we will try to model a voting system in an electorate using Reactive. The voters can either vote for Alice, Bob, or cast an invalid vote.</p>
<p>Input <code>votes</code> signal:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">votes = Signal(:NoVote)    <span class="co"># Let&#39;s :NoVote to denote the initial case</span></code></pre>
<p>Now we can split the vote stream into votes for alice and those for bob.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">alice_votes = filter(v -&gt; v == :Alice, votes)
bob_votes   = filter(v -&gt; v == :Bob, votes)</code></pre>
<p>Now let's count the votes cast for alice and bob using foldp</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">function</span> count(cnt, _)
  cnt+<span class="fl">1</span>
<span class="kw">end</span>

alice_count = foldp(count, <span class="fl">0</span>, alice_votes)
bob_count = foldp(count, <span class="fl">0</span>, bob_votes)</code></pre>
<p>We can use the counts to show at real time who is leading the election.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">leading = map(alice_count, bob_count) <span class="kw">do</span> a, b
  <span class="kw">if</span> a &gt; b
    :Alice
  <span class="kw">elseif</span> b &gt; a
    :Bob
  <span class="kw">else</span>
    :Tie
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>Notice the use of <a href="http://docs.julialang.org/en/release-0.4/manual/functions/#do-block-syntax-for-function-arguments"><code>do</code> block</a> syntax here. <code>do</code> is a short-hand for creating anonymous functions and passing it as the first argument in a function call (here, to <code>map</code>). It's often useful to improve readability.</p>
<p>Notice that the <code>leading</code> signal will update on every valid vote received. This is not ideal if we want to say broadcast it to someone over a slow connection, which will result in sending the same value over and over again. To alleviate this problem, we can use the droprepeats function.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">norepeats = droprepeats(leading)</code></pre>
<p>To demonstrate the use of <code>filterwhen</code> we will conceive a global <code>election_switch</code> signal which can be used to turn voting on or turn off. One could use this switch to stop registering votes before and after the designated time for votes, for example.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">secure_votes = filterwhen(election_switch, votes)</code></pre>
<p><code>secure_votes</code> will only update when <code>value(election_switch)</code> is <code>true</code>.</p>
<p>Finally, to demonstrate the use of merge, let's imagine there are multiple polling stations for this election and we would like to merge votes coming in from all of them. This is pretty straightforward:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">votes = merge(poll1_votes, poll2_votes, poll3_votes)</code></pre>
<h2 id="time-sampling-and-throttle">Time, sampling and throttle</h2>
<p>Reactive provides functions to create timed signals. <a href="api.html#every"><code>every</code></a> can be used to create a signal that updates at a certain interval.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>

every10secs = every(<span class="fl">10.0</span>)</code></pre>
<p><code>every10secs</code> is a signal of timestamps (Float64) which updates every 10 seconds.</p>
<p><a href="api.html#sampleon"><code>sampleon</code></a> function takes two signals and samples the second signal when the first one changes.</p>
<p>Let's say in our voting example, we want a signal of the leading voted candidate in the election but would like an update at most every 10 seconds, one could do it like this:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>
periodic_leading = sampleon(every10secs, leading)</code></pre>
<p><code>throttle</code> lets you limit updates to a signal to a maximum of one update in a specified interval of time.</p>
<p>Suppose you are receiving an input from a sensor and the sampling rate of it can vary and sometimes becomes too high for your program to handle, you can use throttle to down sample it if the frequency of updates become too high.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">throttle(<span class="fl">1</span>/<span class="fl">100</span>, sensor_input) <span class="co"># Update at most once in 10ms</span></code></pre>
<h1 id="reactive-in-the-wild">Reactive in the wild</h1>
<p>Reactive is a great substrate to build interactive GUI libraries. Here are a few projects that make use of Reactive:</p>
<ul>
<li><a href="https://github.com/JuliaLang/Interact.jl">Interact.jl</a></li>
<li><a href="https://github.com/shashi/Escher.jl">Escher.jl</a></li>
<li><a href="https://github.com/SimonDanisch/GLPlot.jl">GLPlot.jl</a></li>
</ul>
<p>It could also be potentially used for other projects that require any kind of event handling: controlling robots, making music or simulations.</p>
<h1 id="reporting-bugs">Reporting Bugs</h1>
<p>Let me know about any bugs, counterintuitive behavior, or enhancements you'd like by <a href="https://github.com/shashi/Reactive.jl/issues/new">filing a bug</a> on github.</p>
        <hr>
      </div>
      </div>

      <div class="col-sm-offset-8" style="z-index: 2">
        <div id="table-of-contents">
          <div id="table-of-contents-content">
            <input class="search" placeholder="SEARCH" />
            <ul class="toc list nav"><li>
                <a class="toc-item toc-current-doc" href="index.html">Introduction - Reactive.jl</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#what-is-reactive-programming">What is reactive programming?</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#getting-started">Getting Started</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#a-tutorial-introduction">A Tutorial Introduction</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#signals">Signals</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#derived-signals">Derived signals</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#maintaining-state">Maintaining State</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#filtering">Filtering</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#merging">Merging</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#drop-repeats">Drop repeats</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#time-sampling-and-throttle">Time, sampling and throttle</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#reactive-in-the-wild">Reactive in the wild</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#reporting-bugs">Reporting Bugs</a>
            </li>
            <li>
                <a class="toc-item" href="api.html">API</a>
            </li>
            </ul>

            <script>
                var toclist = new List("table-of-contents",
                                       {valueNames: ["toc-item"]})

                $("body").scrollspy({target: "#table-of-contents"});

                $("#table-of-contents li").on("activate.bs.scrollspy",
                    function(event) {
                        $("#table-of-contents ul").find("a").css({"font-weight": "normal"});
                        $(this).children("a").css({"font-weight": "bolder"});
                    });
            </script>
          </div>
        </div>
      </div>
    </div>

  <footer class="col-sm-8">
    <p class="muted">Last modified by Shashi Gowda on Tue Apr 12 11:11:09 IST 2016. Generated with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

